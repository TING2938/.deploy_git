<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++矩阵库（2）</title>
    <link href="/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/"/>
    <url>/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前介绍了一些<a href="https://ting2938.github.io/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/" target="_blank" rel="noopener">常见的C++矩阵库</a>，这些矩阵库用起来都很方便，但是在本人的科研过程中并不会用到这些矩阵库的高级功能（如LU分解、求逆矩阵等），只是需要其作为容器存放数据，而且需要一些定制功能（比如元素查找、求积分微分等），因此我写了一个简单的、只包含头文件的矩阵库。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>由于是只包含头文件的，所以很容易包含到其他项目中，安装方法如下：</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/TING2938/Analysis.gitcp -r Analysis/gmxProject/Analysis/Core/include path/to/your/project</code></pre><p>然后设置项目中包含<code>include</code>文件夹就可以用了。</p><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>一个简单的Demo如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;itp/core&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">mati <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != A.nrow(); ++i)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j != A.ncol(); ++j)        &#123;            A(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;            <span class="hljs-comment">// 也可以用方括号进行索引</span>            <span class="hljs-comment">// A[i][j] = 3*i+5*j; </span>        &#125;    &#125;    A.<span class="hljs-built_in">print</span>(<span class="hljs-string">"A:"</span>);&#125;</code></pre><p>会得到如下输出:</p><pre><code class="hljs plain">A:           0           5          10          15           3           8          13          18           6          11          16          21</code></pre><p>其中，<code>mati</code>类型等为一些常用的类型，<code>using mati = itp::Matrix&lt;int&gt;</code>，其他类型如<code>matd</code>、<code>matu</code>、<code>matb</code>分别对应模板参数为<code>double</code>、<code>size_t</code>、<code>bool</code>的版本。</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code class="hljs c++">Matrix();Matrix(<span class="hljs-keyword">size_t</span> nrow, <span class="hljs-keyword">size_t</span> ncol); <span class="hljs-comment">// 指定行列大小，初始值未定义</span>Matrix(<span class="hljs-keyword">size_t</span> nrow, <span class="hljs-keyword">size_t</span> ncol, T init); <span class="hljs-comment">// 指定初始值为 init</span>Matrix(<span class="hljs-keyword">size_t</span> nrow, <span class="hljs-keyword">size_t</span> ncol, conststd::<span class="hljs-built_in">initializer_list</span>&lt;T&gt;&amp; it); <span class="hljs-comment">//指定行列大小，并由初始化列表初始化，如 mati A(2, 3, &#123;2, 3, 4, 5, 5, 6&#125;);</span>Matrix(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">initializer_list</span>&lt;conststd::<span class="hljs-built_in">initializer_list</span>&lt;T&gt;&gt;&amp; it); <span class="hljs-comment">// 由初始化列表初始化，如 mati B = &#123;&#123;5, 6, 8&#125;, &#123;7, 10, 13&#125;&#125;; 初始化为2行3列的矩阵</span>Matrix(T* p, <span class="hljs-keyword">size_t</span> nrow, <span class="hljs-keyword">size_t</span> ncol, <span class="hljs-keyword">bool</span> copy= <span class="hljs-literal">true</span>); <span class="hljs-comment">// 由指针初始化，默认拷贝指针指向的资源，copy=false时不拷贝资源，此时p的生命周期一定要大于矩阵的生命周期</span>Matrix(Matrix&lt;T&gt;&amp;&amp; mat) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 移动构造</span>Matrix(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat); <span class="hljs-comment">// 拷贝构造</span>~Matrix(); <span class="hljs-comment">// 析构函数</span>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(Matrix&lt;T&gt;&amp;&amp; mat) <span class="hljs-keyword">noexcept</span>; <span class="hljs-comment">// 移动赋值运算符</span>Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat); <span class="hljs-comment">// 拷贝赋值运算符</span></code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><pre><code class="hljs c++">T* <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> i) <span class="hljs-keyword">noexcept</span>; <span class="hljs-keyword">const</span> T* <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">size_t</span> i) <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>;Vector&lt;T&gt; <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">const</span> Matrix&lt;<span class="hljs-keyword">bool</span>&gt;&amp; bol) <span class="hljs-keyword">const</span>;<span class="hljs-function">T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-function"><span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-comment">// row major</span><span class="hljs-function">T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> i)</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-function"><span class="hljs-keyword">const</span> T&amp; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> i)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span></span>;<span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Matrix&lt;<span class="hljs-keyword">bool</span>&gt;&amp; bol)</span> <span class="hljs-keyword">const</span></span>;</code></pre><p>采用row major内存布局，索引若只含一维，则将矩阵视为一维向量进行索引，如<code>A[4] = 3</code>;<br>注意，可以采用<code>()</code>和<code>[]</code>两种方法进行索引，如<code>A(1, 2) = 5; B[4][3] = 6</code>，两种方法效果一样</p><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p><strong>注意：矩阵所有运算都是将矩阵视为向量后的运算，并不涉及真正的矩阵运算。</strong></p><p>例如，<code>mati A(3, 4), B(3, 4)</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A + 3</code></td><td><code>A</code>所有元素加3</td></tr><tr><td><code>A + B</code></td><td><code>A</code>与<code>B</code>对应元素相加</td></tr><tr><td><code>A &gt; 2</code></td><td><code>A</code>中元素分别与2比较，返回与<code>A</code>形状相同的bool型矩阵</td></tr><tr><td><code>A &gt; B</code></td><td><code>A</code>中元素分别与<code>B</code>中元素比较，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr><tr><td><code>!A</code></td><td>对<code>A</code>中元素分别求非运算，返回与<code>A</code>形状相同的bool型矩阵</td></tr><tr><td><code>A &amp;&amp; B</code></td><td>对<code>A</code>与<code>B</code>中对应元素求与运算，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr><tr><td><code>A</code> &#124;&#124; <code>B</code></td><td>对<code>A</code>与<code>B</code>中对应元素求或运算，返回与<code>A</code>(或<code>B</code>)形状相同的bool型矩阵</td></tr></tbody></table><p>矩阵与数：</p><pre><code class="hljs c++">Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> T&amp; val);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-keyword">const</span> T&amp; val);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-keyword">const</span> T&amp; val);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-keyword">const</span> T&amp; val);Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> T&amp; val) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> T&amp; val) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> T&amp; val) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> T&amp; val) <span class="hljs-keyword">const</span>;</code></pre><p>矩阵与矩阵：</p><pre><code class="hljs c++">Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat);Matrix&lt;T&gt;&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat);Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>-(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;T&gt; <span class="hljs-keyword">operator</span>/(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;</code></pre><p>矩阵与数之间的比较：</p><pre><code class="hljs c++">Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> T&amp; value) <span class="hljs-keyword">const</span>;</code></pre><p>矩阵与矩阵之间的比较：</p><pre><code class="hljs c++">Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&lt;=(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat) <span class="hljs-keyword">const</span>;</code></pre><p>逻辑运算符：</p><pre><code class="hljs c++">Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>!() <span class="hljs-keyword">const</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S&gt;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>&amp;&amp;(<span class="hljs-keyword">const</span> Matrix&lt;S&gt;&amp; mat) <span class="hljs-keyword">const</span>;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> S&gt;Matrix&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-keyword">operator</span>||(<span class="hljs-keyword">const</span> Matrix&lt;S&gt;&amp; mat) <span class="hljs-keyword">const</span>;</code></pre><h3 id="矩阵切片操作"><a href="#矩阵切片操作" class="headerlink" title="矩阵切片操作"></a>矩阵切片操作</h3><p>例如，<code>mati A(3, 4)</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A.part(2, {1, 3})</code></td><td>第2行、第1到3列</td></tr><tr><td><code>A.part({0, 2}, 1)</code></td><td>第0到2行、第1列</td></tr><tr><td><code>A.part({0, 2}, {1, 3})</code></td><td>第0到2行、第1到3列</td></tr><tr><td><code>A.head(2)</code></td><td>前2行</td></tr><tr><td><code>A.tail(2)</code></td><td>后2行</td></tr></tbody></table><pre><code class="hljs c++"><span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Rg&amp; row, <span class="hljs-keyword">const</span> Rg&amp; col)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> row, <span class="hljs-keyword">const</span> Rg&amp; rg, boolcopy = <span class="hljs-literal">false</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Rg&amp; rg, <span class="hljs-keyword">size_t</span> col)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> row = <span class="hljs-number">10</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">tail</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> row = <span class="hljs-number">10</span>)</span> <span class="hljs-keyword">const</span></span>;</code></pre><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>例如，<code>mati A(3, 4), B(4, 5);</code></p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td><code>A.nrow()</code></td><td>行数</td></tr><tr><td><code>A.ncol()</code></td><td>列数</td></tr><tr><td><code>A.size()</code></td><td>存入<code>std::array</code>的行列数</td></tr><tr><td><code>A.size(0)</code></td><td>行数</td></tr><tr><td><code>A.size(1)</code></td><td>列数</td></tr><tr><td><code>A.capacity()</code></td><td>内部指针的容量</td></tr><tr><td><code>A.fill(3)</code></td><td>用3填充整个矩阵</td></tr><tr><td><code>A.resize(4, 5)</code></td><td>重置大小为4行5列</td></tr><tr><td><code>A.clear()</code></td><td>使矩阵的行列数都为0</td></tr><tr><td><code>A.fillRandom(std::uniform_int_distribution&lt;int&gt;(1, 6))</code></td><td>用从1到6之间的均匀分布随机数填充，随机数用法参考标准库中<a href="https://en.cppreference.com/w/cpp/header/random" target="_blank" rel="noopener">随机数部分</a></td></tr><tr><td><code>A.dot(B)</code></td><td><code>A</code>与<code>B</code>的矩阵点乘</td></tr><tr><td><code>A.transpose()</code></td><td>转置</td></tr><tr><td><code>A.max(COL)</code></td><td>列方向上的最大值，返回向量</td></tr><tr><td><code>A.min(COL)</code></td><td>列方向上的最小值，返回向量</td></tr><tr><td><code>A.sum(COL)</code></td><td>列方向上的和，返回向量</td></tr><tr><td><code>A.mean(COL)</code></td><td>列方向上的平均值，返回向量</td></tr><tr><td><code>A.stdev(COL)</code></td><td>列方向上的标准差，返回向量</td></tr><tr><td><code>A.max(2, COL)</code></td><td>第2列上的最大值</td></tr><tr><td><code>A.print(&quot;A:&quot;, std::cout, &quot;{:12}&quot;)</code></td><td>向<code>std::cout</code>中打印输出<code>A</code>，提示符为<code>A:</code>，格式为<code>&quot;{:12}&quot;</code></td></tr></tbody></table><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">nrow</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">ncol</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;std::array&lt;size_t, 2&gt; size() const;<span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> i)</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">/* i &lt; 2. */</span><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span>&amp; <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">size_t</span>&amp; <span class="hljs-title">capacity</span><span class="hljs-params">()</span></span>;<span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; value)</span></span>;<span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> nrow, <span class="hljs-keyword">size_t</span> ncol)</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/* https://en.cppreference.com/w/cpp/header/random */</span><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Distribution&gt;<span class="hljs-function">Matrix&lt;T&gt;&amp; <span class="hljs-title">fillRandom</span><span class="hljs-params">(Distribution&amp;&amp; dist)</span></span>;<span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">dot</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Matrix&lt;T&gt;&amp; mat)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Matrix&lt;T&gt; <span class="hljs-title">transpose</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/* calculate value of block  */</span><span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">max</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">min</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;T&gt; <span class="hljs-title">sum</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">mean</span><span class="hljs-params">(Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">Vector&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">stdev</span><span class="hljs-params">(Axis axis = COL, <span class="hljs-keyword">bool</span> sample = <span class="hljs-literal">true</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-comment">/* calculate value of row or column */</span><span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">mean</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, Axis axis = COL)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">stdev</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> n, Axis axis = COL, <span class="hljs-keyword">bool</span> sample = <span class="hljs-literal">true</span>)</span> <span class="hljs-keyword">const</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> str = <span class="hljs-string">""</span>, <span class="hljs-built_in">std</span>::ostream&amp; os = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fmt=<span class="hljs-string">"&#123;:12&#125;"</span>)</span> <span class="hljs-keyword">const</span></span>;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gromacs轨迹分析工具</title>
    <link href="/2020/05/21/Gromacs%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/05/21/Gromacs%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.gromacs.org/" target="_blank" rel="noopener">Gromacs</a>是一款十分优秀的分子动力学软件，其并行化运行速度快，后处理命令丰富d</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Gromacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++矩阵库</title>
    <link href="/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/"/>
    <url>/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++以其及其优异的计算速度在科学计算、工业工程等领域得到广泛的应用，在数值计算方面，调用矩阵库能简化编程过程，提高计算速度，下面介绍几种常用的矩阵库及其用法，此外，我也写了一个矩阵库在自己科研分析中<a href="https://ting2938.github.io/2020/05/22/C-%E7%9F%A9%E9%98%B5%E5%BA%93%EF%BC%882%EF%BC%89/" target="_blank" rel="noopener">C++矩阵库（2）</a>。</p><h3 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h3><p><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener">Eigen</a>是采用C++模板技术编写的纯头文件库，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Eigen/Dense&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Eigen::MatrixXd <span class="hljs-title">mat</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)        &#123;            mat(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;        &#125;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; mat &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="Armadillo"><a href="#Armadillo" class="headerlink" title="Armadillo"></a>Armadillo</h3><p><a href="http://arma.sourceforge.net/" target="_blank" rel="noopener">Armadillo</a>的语法与Matlab语法很相识，从Matlab迁移到Armadillo很方便，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Armadillo&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">arma::mat <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)        &#123;            A(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;        &#125;    &#125;    A.<span class="hljs-built_in">print</span>(<span class="hljs-string">"A:"</span>);&#125;</code></pre><h3 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h3><p><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a>在C++中地位非常高，被称为C++的准标准库，其中的ublas模块包含矩阵类，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/numeric/ublas/matrix.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/numeric/ublas/io.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">namespace</span> ublas = boost::numeric::ublas;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">ublas::matrix&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; A.size1(); ++i)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; A.size2(); ++j)            A(i, j) = <span class="hljs-number">3</span>*i + j;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; A &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++控制台设置滚动输出</title>
    <link href="/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/"/>
    <url>/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写C++控制台程序时，我们可能会给程序添加进度条，也就是要程序在同一行反复输出，可以用特殊字符实现。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="在Windows下"><a href="#在Windows下" class="headerlink" title="在Windows下"></a>在Windows下</h3><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r"</span>);    fflush(<span class="hljs-built_in">stdout</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre><h3 id="在Linux下"><a href="#在Linux下" class="headerlink" title="在Linux下"></a>在Linux下</h3><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\033[k"</span>);    fflush(<span class="hljs-built_in">stdout</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里写一个函数<code>setScrollOutput()</code>来实现这一过程：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScrollOutput</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\033[k"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _WIN32</span></span>fflush(<span class="hljs-built_in">stdout</span>);&#125;</code></pre><p>使用过程如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    setScrollOutput();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMD原子选区语法</title>
    <link href="/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>VMD（<a href="http://www.ks.uiuc.edu/Research/vmd/" target="_blank" rel="noopener">http://www.ks.uiuc.edu/Research/vmd/</a>）是极其强大、灵活的化学体系可视化程序，笔者之前也写过不少相关文章，见<a href="http://sobereva.com/category/VMD/" target="_blank" rel="noopener">http://sobereva.com/category/VMD/</a>。VMD的选择语句(selection)用来选择满足特定要求的体系中的原子，其用法极度简单灵活，对于VMD的使用至关重要。</p><p>选择语句在VMD里用的地方非常多，无处不在。比如如果想在图形窗口只显示指定的区域，那么可以在Graphics - Representation里在selected atoms的地方写上选择语句。如果想把指定的区域保存成新文件，那么可以在File - Save coordinates里在Selected atoms写上选择语句。很多自带的插件也需要选择语句，比如VMD自带的径向分布函数计算插件，里面selection 1、selection 2就是让你输入选择语句的地方。在VMD里还可以用atomselect命令创建对象，显然也要输入选择语句。顺带一提，如今GROMACS里也可以用selections语句，和VMD很大程度一致，但不完全一致。</p><p>鉴于经常有人问选择语句怎么用，每次回复很麻烦，笔者遂专门写个小文说一下。这些内容在“北京科音分子动力学与GROMACS培训班里”（<a href="http://www.keinsci.com/workshop/KGMX_content.html" target="_blank" rel="noopener">http://www.keinsci.com/workshop/KGMX_content.html</a>）里大多也都讲过，之前的学员可以复习一下。本文内容对应VMD 1.9.3。下文从简单到复杂进行讲解。</p><h2 id="2-单关键词（Singleword）"><a href="#2-单关键词（Singleword）" class="headerlink" title="2 单关键词（Singleword）"></a><strong>2 单关键词（Singleword）</strong></h2><p>有一些关键词可以直接选择特定原子，以下举例一部分：</p><p> all：所有原子</p><p> none：不选择任何原子</p><p> noh：氢以外的原子（即重原子）</p><p> ion：离子</p><p> water：水</p><p> backbone：生物大分子骨架</p><p> sidechain：生物大分子侧链</p><p> protein：蛋白</p><p> nucleic：核酸</p><p> helix：螺旋</p><p> alpha_helix：alpha螺旋（是helix中的子集，较长一段螺旋才算）</p><p> sheet：折叠</p><p> turn：转角</p><p> coil：盘绕</p><p> alpha：蛋白质的alpha碳</p><p> acidic：PH=7时带负电氨基酸</p><p> basic：PH=7时带正电氨基酸</p><p> charged：acidic和basic的并集</p><p> neutral：电中性氨基酸</p><p> polar：极性残基</p><p> hydrophobic：疏水性残基</p><p> bonded：成键的原子</p><p> hetero：非蛋白质和核酸的部分</p><p> carbon、hydrogen、oxygen、nitrogen、sulfur：相应元素。对于其它元素没法这么输入元素名来选择</p><p>这些单关键词实际上可以在Representation界面里的Selections标签页里的Singlewords直接看到，可见可以用的单关键词远不止上述这些。有些单关键词其实是复合选择语句，比如你选中hetero，就会看到其定义其实是not (protein or nucleic)。</p><p><img src="/images/vmd_1.png" srcset="/img/loading.gif" alt=""></p><p>注意有些情况下，单关键词未必能如实选择相应的区域。比如你载入的结构里有水，如果输入文件里水的残基名很特殊，比如叫FFF，那么VMD就不会把这个残基识别成水分子，用water关键词的时候也没法选中这些水。</p><h2 id="3-一般关键词"><a href="#3-一般关键词" class="headerlink" title="3 一般关键词"></a><strong>3 一般关键词</strong></h2><p>用下面这些关键词可以通过属性选取原子，都是后面要接参数的</p><p> name：原子名。例：name OW选择原子名叫OW的原子</p><p> index：原子序号（从0开始！）。例：index 4</p><p> serial：原子序号（从1开始）</p><p> type：原子类型。例：type CA选择CA原则类型</p><p> element：元素名。例：element P选择磷原子</p><p> resname：残基名。例：resname ALA代表选择丙氨酸</p><p> residue：残基编号，从0开始。例resid 372代表选择372号残基</p><p> resid：残基编号，从1开始。若结构文件里有残基号则与之一致</p><p> chain：链名。例：chain B代表选择B链</p><p> fragment：片段编号。VMD对每个键连的片段自动设定一个编号。例：fragment 4代表选择片段4</p><p> numbonds：成键数目。例：numbonds=2或numbonds 2代表选形成了两个键的原子</p><p> structure：二级结构。例：structure H代表选择螺旋(helix)区域</p><p> x,y,z：X/Y/Z笛卡尔坐标</p><p> vx,vy,vz：X/Y/Z方向速度</p><p> beta：pdb文件中的beta值</p><p> occupancy：pdb文件中的原子占有率</p><p> mass：原子质量</p><p> charge：原子电荷</p><p> phi、psi：蛋白质骨架角度</p><p> radius：原子半径</p><p>…等等</p><p>每个属性后面能接什么值，在Selections标签页里都能看到，不确定的话看一眼便知：</p><p><img src="/images/vmd_2.png" srcset="/img/loading.gif" alt=""></p><p>许多属性并非对于任何输入文件都能用。比如：</p><p>·使用charge属性，必须输入的文件里体现了原子电荷才行，比如可以用mol2或pqr，后者详见《使用Multiwfn+VMD以原子着色方式表现原子电荷、自旋布居、电荷转移、简缩福井函数》（<a href="http://sobereva.com/425" target="_blank" rel="noopener">http://sobereva.com/425</a>）。</p><p>·使用beta属性，通常需要用pdb文件作为输入，因为里面专门有一列记录B因子信息。</p><p>·用type的话必须载入拓扑文件才行。</p><p>·用vx、vy、vz的话，对于GROMACS用户，参看《使VMD读入Gromacs产生的trr轨迹中速度信息的方法》（<a href="http://sobereva.com/117" target="_blank" rel="noopener">http://sobereva.com/117</a>）。</p><p>·element信息是很多文件里没有的，比如GROMACS的.gro文件里就没体现</p><h2 id="4-选择语句中可利用的规则"><a href="#4-选择语句中可利用的规则" class="headerlink" title="4 选择语句中可利用的规则"></a><strong>4 选择语句中可利用的规则</strong></h2><p>在选择语句中有以下规则可以利用，通过组合、嵌套，使得选择语句无比强大</p><p>·可以写多个参数一次选择一批，彼此间用空格分隔</p><p>·可以用… to …选择特定范围</p><p>·可以用与、或、非这些逻辑关系：and、or、not</p><p>·可以用( )或{ }指定语句处理的优先顺序</p><p>·双引号内的字符会被视为整体，并且可以使用正则表达式</p><p>·用单引号扩住则里面的字符可以避免被转义</p><p>·可以用判断语句：&lt;, &lt;=, =, &gt;=, &gt;, !=</p><p>·可以用函数：sqr（平方）, sqrt（开根号）, abs（绝对值）, sin, cos, tan, atan, asin, acos, sinh, cosh, tanh, exp, log, log10</p><p>·支持运算符：+ - * /。可以用^或**来表示多少次方</p><p>·特殊选择方式：</p><p> within 5 of AAA：距离AAA 5埃以内的原子。选取时不考虑周期边界条件，用pbwithin则考虑</p><p> exwithin 5 of AAA ：同上，但不包含AAA自身</p><p> withinbonds 2 of AAA：距离AAA不超过两个键的原子</p><p> same p as AAA：与AAA选区的p属性相同的部分</p><p> ringsize 5 from AAA：处于AAA中五元环上的原子</p><p> maxringsize 6 from AAA：处于AAA中&lt;=六元环的原子</p><p>下面来看一些具体例子</p><p> index 5 to 200 210：序号在5~200内的原子以及210号原子</p><p> protein or nucleic：蛋白质与核酸的原子</p><p> resname ALA CYS ARG：丙氨酸、半胱氨酸、精氨酸原子</p><p> backbone not helix：除了螺旋区域以外的骨架原子</p><p> name CA CB 或 name “CA|CB” 或 name “C[AB]” 或 name “C(A|B)”：名为CA和CB的原子</p><p> name “C.”：名字为两个字符且第一个字符为C的原子</p><p> name “CE[1-3]”：名字为CE1、CE2、CE3的原子</p><p> name ‘O5<em>‘：叫O5</em>的原子。注意原子名带星号的在选取时要用单引号括住以免转义</p><p> resname ‘CA2+’：残基名是CA2+的原子（二价钙离子）。名字带正负号的也要用单引号括住以免转义</p><p> mass &gt; 5：质量大于5的原子</p><p> abs(charge)&gt;1：电荷大小超过1的原子</p><p> x&lt;6 and x&gt;3：选择x在3~6埃区域内的一层原子</p><p> x&gt;1 and x&lt;8 and y&gt;24 and y&lt;35 and z&gt;1 and z&lt;5：一个矩形区域内的原子</p><p> sqr(x-5)+sqr(y+4)+sqr(z) &lt; sqr(5) ：以(5,-4,0)点为中心半径5埃以内的原子</p><p> ((x-33)^2+(y-14.5)^2)&lt;12^2 and z&lt;40 and z&gt;10：选择以x=33、y=14.5埃为中心，半径为12埃，z范围在10~40埃的柱形区域</p><p> x+y+z&lt;80：斜切面内侧的原子（回忆平面方程）</p><p> not {oxygen and numbonds=0}：扣除孤立的氧原子（可以用于去除X光衍射pdb文件里的结晶水）</p><p> within 6 of protein：距离蛋白质6埃以内的原子</p><p> not within 5 of resname ADP：距离名为ADP的分子5埃以外的原子</p><p> water within 5 of residue 8 to 44：距离8~44号残基5埃以内的水</p><p> withinbonds 2 of index 31：距离编号为31原子的两个键及以内的原子</p><p> maxringsize 6 from protein：蛋白当中所有六元及六元以下环上的原子</p><p> same resname as resid 33：所有与33号残基相同名称的残基</p><p> same residue as {protein within 5 of nucleic}：与核酸的原子相距5埃以内的蛋白的原子，并且把被截断的残基保留完整</p><p> x &gt; 15 and not same fragment as {exwithin 8 of protein}：蛋白质以及蛋白质8埃范围以外的原子，保留完整片段，同时x坐标得大于15埃</p><p>以上例子中，涉及到坐标、速度变量的，属于动态选区，即随着帧号变化被选择的原子会可能发生变化。观看这些选区的时候，注意在Representation界面的Trajectory标签页里要把Update Selection Every Frame选上，否则选中的原子是对刚选中时那一帧而言的，不会随着轨迹播放被动态更新。在一些VMD的插件中，比如计算rdf的Radial Pair Distribution Function g(r)插件里，当Selection文本框里用了动态选区时，应当把Update Selections复选框选上，否则也由于不会被动态更新而和期望的不符。</p><blockquote><p>转自 <a href="http://bbs.keinsci.com/thread-14267-1-1.html" target="_blank" rel="noopener">http://bbs.keinsci.com/thread-14267-1-1.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具网站汇总</title>
    <link href="/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="http://tinyambition.com/h2m/" target="_blank" rel="noopener">HTML转Markdown</a></li><li><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">在线Markdown编辑器</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab绘制图组</title>
    <link href="/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/"/>
    <url>/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在用Matlab的<code>subplot</code>函数绘制图组时可能会发现子图之间的间距不太好看，可以通过<code>set(&#39;Position&#39;, [l, b, w, h])</code>函数来分别调整，比较麻烦，这里我写了一个函数<code>subplot_adjust</code>来简化这一过程。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>function <code>subplots_adjust(row, col, varargin)</code></p><p>Tune the subplot layout.</p><p>The parameter meanings (and suggested defaults) are</p><pre><code>left = 0.12    # the left side of the subplots of the figurebottom = 0.138 # the bottom of the subplots of the figurewidth = 0.8    # the width of the subplots of the figurehight = 0.78   # the hight of the subplots of the figurewspace = 0.12  # the amount of width reserved for space between subplots,               # expressed as a fraction of the average axis widthhspace = 0.1   # the amount of height reserved for space between subplots,               # expressed as a fraction of the average axis heightsupPosition = [0.075, 0.08, 0.9, 0.85]                # [left, bottom, width, hight]               # super axes position, which controls position of               # supxlabel, supylabel and suptitle.</code></pre><p>在用<code>subplot</code>画完图组后，直接在最后面加上<code>subplot_adjust</code>即可，例如：</p><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);y1 = <span class="hljs-built_in">sin</span>(x);y2 = <span class="hljs-built_in">cos</span>(x);<span class="hljs-built_in">figure</span>(<span class="hljs-string">'Position'</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>, <span class="hljs-number">550</span>]);subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">plot</span>(x, y1)subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<span class="hljs-built_in">plot</span>(x, y2)ax = subplots_adjust(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'hspace'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'left'</span>, <span class="hljs-number">0.2</span>, ...                    <span class="hljs-string">'width'</span>, <span class="hljs-number">0.75</span>, <span class="hljs-string">'supPosition'</span>, [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.85</span>]);xlabel(ax, <span class="hljs-string">'xlabel'</span>)ylabel(ax, <span class="hljs-string">'ylabel'</span>)title(ax, <span class="hljs-string">'Title'</span>)</code></pre><p>绘制2行1列图组，设置两子图之间纵向间距为0，结果如下：</p><div align=center><img src="/images/subplot_adjust.png" srcset="/img/loading.gif" width="50%" height="50%"></div><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ax</span> = <span class="hljs-title">subplots_adjust</span><span class="hljs-params">(row, col, varargin)</span></span><span class="hljs-comment">%% function subplots_adjust(row, col, varargin)</span><span class="hljs-comment">% Tune the subplot layout.</span><span class="hljs-comment">% </span><span class="hljs-comment">% The parameter meanings (and suggested defaults) are::</span><span class="hljs-comment">% </span><span class="hljs-comment">%   left = 0.12    # the left side of the subplots of the figure</span><span class="hljs-comment">%   bottom = 0.138 # the bottom of the subplots of the figure</span><span class="hljs-comment">%   width = 0.8    # the width of the subplots of the figure</span><span class="hljs-comment">%   hight = 0.78   # the hight of the subplots of the figure</span><span class="hljs-comment">%   wspace = 0.12  # the amount of width reserved for space between subplots,</span><span class="hljs-comment">%                  # expressed as a fraction of the average axis width</span><span class="hljs-comment">%   hspace = 0.1   # the amount of height reserved for space between subplots,</span><span class="hljs-comment">%                  # expressed as a fraction of the average axis height</span><span class="hljs-comment">%   supPosition = [0.075, 0.08, 0.9, 0.85] </span><span class="hljs-comment">%                  # [left, bottom, width, hight]</span><span class="hljs-comment">%                  # super axes position, which controls position of</span><span class="hljs-comment">%                  # supxlabel, supylabel and suptitle.</span><span class="hljs-comment">%</span><span class="hljs-comment">% Example:</span><span class="hljs-comment">% x = linspace(0, 10);</span><span class="hljs-comment">% y1 = sin(x);</span><span class="hljs-comment">% y2 = cos(x);</span><span class="hljs-comment">% figure('Position', [10, 50, 400, 550]);</span><span class="hljs-comment">% subplot(2, 1, 1)</span><span class="hljs-comment">% plot(x, y1)</span><span class="hljs-comment">% subplot(2, 1, 2)</span><span class="hljs-comment">% plot(x, y2)</span><span class="hljs-comment">% ax = subplots_adjust(2, 1, 'hspace', 0, 'left', 0.2, ...</span><span class="hljs-comment">%                      'width', 0.75, 'supPosition', [0.1, 0.08, 0.95, 0.85]);</span><span class="hljs-comment">% xlabel(ax, 'xlabel')</span><span class="hljs-comment">% ylabel(ax, 'ylabel')</span><span class="hljs-comment">% title(ax, 'Title')</span>p = inputParser;addRequired(p, <span class="hljs-string">'row'</span>);addRequired(p, <span class="hljs-string">'col'</span>);addParameter(p, <span class="hljs-string">'wspace'</span>, <span class="hljs-number">0.12</span>);addParameter(p, <span class="hljs-string">'hspace'</span>, <span class="hljs-number">0.1</span>);addParameter(p, <span class="hljs-string">'left'</span>, <span class="hljs-number">0.12</span>);addParameter(p, <span class="hljs-string">'bottom'</span>, <span class="hljs-number">0.138</span>);addParameter(p, <span class="hljs-string">'width'</span>, <span class="hljs-number">0.8</span>);addParameter(p, <span class="hljs-string">'hight'</span>, <span class="hljs-number">0.78</span>);addParameter(p, <span class="hljs-string">'supPosition'</span>, [<span class="hljs-number">0.075</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.85</span>]);parse(p, row, col, varargin&#123;:&#125;);left   = p.Results.left;bottom = p.Results.bottom;width  = p.Results.width;hight  = p.Results.hight;space = [p.Results.wspace, p.Results.hspace];eachx = (width-(col<span class="hljs-number">-1</span>)*space(<span class="hljs-number">1</span>)) / col;eachy = (hight-(row<span class="hljs-number">-1</span>)*space(<span class="hljs-number">2</span>)) / row;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:row    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:col        h = subplot(row, col, (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*col+<span class="hljs-built_in">j</span>);        set(h, <span class="hljs-string">'position'</span>, [left+(<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)*(eachx+space(<span class="hljs-number">1</span>)), bottom+(row-<span class="hljs-built_in">i</span>)*(eachy+space(<span class="hljs-number">2</span>)), eachx, eachy]);        <span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> ~= <span class="hljs-number">1</span> &amp;&amp; space(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>            set(h, <span class="hljs-string">'YTickLabel'</span>, &#123;&#125;);        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> ~= row &amp;&amp; space(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>            set(h, <span class="hljs-string">'XTickLabel'</span>, &#123;&#125;);        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>ax = axes(<span class="hljs-string">'Units'</span>, <span class="hljs-string">'Normal'</span>, <span class="hljs-string">'Position'</span>, p.Results.supPosition, <span class="hljs-string">'Visible'</span>, <span class="hljs-string">'off'</span>);ax.XTickLabel = &#123;&#125;;ax.YTickLabel = &#123;&#125;;ax.XLabel.Visible = <span class="hljs-string">'on'</span>;ax.YLabel.Visible = <span class="hljs-string">'on'</span>;ax.Title.Visible = <span class="hljs-string">'on'</span>;<span class="hljs-keyword">end</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python线程池的创建和使用</title>
    <link href="/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="✨-前言"><a href="#✨-前言" class="headerlink" title="✨ 前言"></a>✨ 前言</h3><p>从Python3.2开始，标准库为我们提供了 concurrent.futures 模块，它提供了 ThreadPoolExecutor (线程池)和ProcessPoolExecutor (进程池)两个类。</p><p>相比 threading 等模块，该模块通过 submit 返回的是一个 future 对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：</p><ol><li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li><li>当一个线程完成的时候，主线程能够立即知道。</li><li>让多线程和多进程的编码接口一致。</li></ol><h3 id="✨-线程池的基本使用"><a href="#✨-线程池的基本使用" class="headerlink" title="✨ 线程池的基本使用"></a>✨ 线程池的基本使用</h3><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:  <span class="hljs-comment"># 创建一个最大容纳数量为5的线程池</span>    task1 = t.submit(spider, <span class="hljs-number">1</span>)    task2 = t.submit(spider, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 通过submit提交执行的函数到线程池中</span>    task3 = t.submit(spider, <span class="hljs-number">3</span>)    print(<span class="hljs-string">f"task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>"</span>)  <span class="hljs-comment"># 通过done来判断线程是否完成</span>    print(<span class="hljs-string">f"task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>"</span>)    time.sleep(<span class="hljs-number">2.5</span>)    print(<span class="hljs-string">f"task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>"</span>)    print(task1.result())  <span class="hljs-comment"># 通过result来获取返回值</span></code></pre><h5 id="执行结果如下"><a href="#执行结果如下" class="headerlink" title="执行结果如下:"></a>执行结果如下:</h5><pre><code class="hljs plain">task1: Falsetask2: Falsetask3: Falsecrawl task1 finishedcrawl task2 finishedtask1: Truetask2: Truetask3: False1crawl task3 finished</code></pre><ol><li><p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</p></li><li><p>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</p></li><li><p>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</p></li><li><p>使用 result() 方法可以获取任务的返回值。</p></li></ol><h3 id="✨-主要方法："><a href="#✨-主要方法：" class="headerlink" title="✨ 主要方法："></a>✨ 主要方法：</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><pre><code class="hljs plain">wait(fs, timeout&#x3D;None, return_when&#x3D;ALL_COMPLETED)</code></pre><p>wait 接受三个参数： fs: 表示需要执行的序列 timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回 return_when：表示wait返回结果的条件，默认为 ALL_COMPLETED 全部执行完成再返回</p><p>还是用上面那个例子来熟悉用法 示例：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED, ALL_COMPLETED<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:     all_task = [t.submit(spider, page) <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]    wait(all_task, return_when=FIRST_COMPLETED)    print(<span class="hljs-string">'finished'</span>)    print(wait(all_task, timeout=<span class="hljs-number">2.5</span>))<span class="hljs-comment"># 运行结果</span>crawl task1 finishedfinishedcrawl task2 finishedcrawl task3 finishedDoneAndNotDoneFutures(done=&#123;, , &#125;, not_done=&#123;&#125;)crawl task4 finished</code></pre><ol><li>代码中返回的条件是：当完成第一个任务的时候，就停止等待，继续主线程任务</li><li>由于设置了延时， 可以看到最后只有 task4 还在运行中</li></ol><h4 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h4><p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p><p>ThreadPoolExecutorThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果</p><p>用法如下：</p><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:        obj_list = []        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):            obj = t.submit(spider, page)            obj_list.append(obj)        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):            data = future.result()            print(<span class="hljs-string">f"main: <span class="hljs-subst">&#123;data&#125;</span>"</span>)<span class="hljs-comment"># 执行结果</span>crawl task1 finishedmain: <span class="hljs-number">1</span>crawl task2 finishedmain: <span class="hljs-number">2</span>crawl task3 finishedmain: <span class="hljs-number">3</span>crawl task4 finishedmain: <span class="hljs-number">4</span></code></pre><p>as_completed() 方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。</p><p>当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code class="hljs plain">map(fn, *iterables, timeout&#x3D;None)</code></pre><p>fn： 第一个参数 fn 是需要线程执行的函数； iterables：第二个参数接受一个可迭代对象； timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。</p><p>用法如下:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    <span class="hljs-keyword">return</span> pagestart = time.time()executor = ThreadPoolExecutor(max_workers=<span class="hljs-number">4</span>)i = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> executor.map(spider, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]):    print(<span class="hljs-string">"task&#123;&#125;:&#123;&#125;"</span>.format(i, result))    i += <span class="hljs-number">1</span><span class="hljs-comment">#  运行结果</span>task1:<span class="hljs-number">2</span>task2:<span class="hljs-number">3</span>task3:<span class="hljs-number">1</span>task4:<span class="hljs-number">4</span></code></pre><p>使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。</p><p>上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。</p><p>可以看到执行结果与上面的 as_completed() 方法的结果不同，输出顺序和列表的顺序相同，就算 1s 的任务先执行完成，也会先打印前面提交的任务返回的结果。</p><h3 id="✨-实战"><a href="#✨-实战" class="headerlink" title="✨ 实战"></a>✨ 实战</h3><p>以某网站为例，演示线程池和单线程两种方式爬取的差异</p><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> adapters<span class="hljs-keyword">from</span> proxy <span class="hljs-keyword">import</span> get_proxiesheaders = &#123;    <span class="hljs-string">"Host"</span>: <span class="hljs-string">"splcgk.court.gov.cn"</span>,    <span class="hljs-string">"Origin"</span>: <span class="hljs-string">"https://splcgk.court.gov.cn"</span>,    <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>,    <span class="hljs-string">"Referer"</span>: <span class="hljs-string">"https://splcgk.court.gov.cn/gzfwww/ktgg"</span>,&#125;url = <span class="hljs-string">"https://splcgk.court.gov.cn/gzfwww/ktgglist?pageNo=1"</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    data = &#123;        <span class="hljs-string">"bt"</span>: <span class="hljs-string">""</span>,        <span class="hljs-string">"fydw"</span>: <span class="hljs-string">""</span>,        <span class="hljs-string">"pageNum"</span>: page,    &#125;    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        <span class="hljs-keyword">try</span>:            response = requests.post(url, headers=headers, data=data, proxies=get_proxies())            json_data = response.json()        <span class="hljs-keyword">except</span> (json.JSONDecodeError, adapters.SSLError):            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> &#123;&#125;    <span class="hljs-keyword">return</span> json_data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">8</span>) <span class="hljs-keyword">as</span> t:        obj_list = []        begin = time.time()        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):            obj = t.submit(spider, page)            obj_list.append(obj)        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):            data = future.result()            print(data)            print(<span class="hljs-string">'*'</span> * <span class="hljs-number">50</span>)        times = time.time() - begin        print(times)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><p>运行结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/6/16b2cf5c38d862ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="多线程"></p><p><strong>可以看到，14 页只花了 2 秒钟就爬完了</strong></p><p>下面我们可以使用单线程来爬取，代码基本和上面的一样，加个单线程函数 代码如下:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">single</span><span class="hljs-params">()</span>:</span>    begin = time.time()    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):        data = spider(page)        print(data)        print(<span class="hljs-string">'*'</span> * <span class="hljs-number">50</span>)    times = time.time() - begin    print(times)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    single()</code></pre><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/6/16b2cf5c38438238?imageslim" srcset="/img/loading.gif" alt="单线程"></p><p><strong>可以看到，总共花了 19 秒。真是肉眼可见的差距啊！如果数据量大的话，运行时间差距会更大！</strong></p><blockquote><p>转自：<a href="https://juejin.im/post/5cf913cfe51d45105d63a4d0" target="_blank" rel="noopener">https://juejin.im/post/5cf913cfe51d45105d63a4d0</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
