<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/22/hello-world/"/>
    <url>/2020/05/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Gromacs轨迹分析工具</title>
    <link href="/2020/05/21/Gromacs%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
    <url>/2020/05/21/Gromacs%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.gromacs.org/" target="_blank" rel="noopener">Gromacs</a>是一款十分优秀的分子动力学软件，其并行化运行速度快，后处理命令丰富</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Gromacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++矩阵库</title>
    <link href="/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/"/>
    <url>/2020/05/20/C-%E7%9F%A9%E9%98%B5%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C++以其及其优异的计算速度在科学计算、工业工程等领域得到广泛的应用，在数值计算方面，调用矩阵库能简化编程过程，提高计算速度，下面介绍几种常用的矩阵库及其用法。</p><h3 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h3><p><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener">Eigen</a>是采用C++模板技术编写的纯头文件库，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Eigen/Dense&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">Eigen::MatrixXd <span class="hljs-title">mat</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)        &#123;            mat(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;        &#125;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; mat &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="Armadillo"><a href="#Armadillo" class="headerlink" title="Armadillo"></a>Armadillo</h3><p><a href="http://arma.sourceforge.net/" target="_blank" rel="noopener">Armadillo</a>的语法与Matlab语法很相识，从Matlab迁移到Armadillo很方便，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Armadillo&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">arma::mat <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">3</span>; ++i)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j != <span class="hljs-number">4</span>; ++j)        &#123;            A(i, j) = <span class="hljs-number">3</span>*i+<span class="hljs-number">5</span>*j;        &#125;    &#125;    A.<span class="hljs-built_in">print</span>(<span class="hljs-string">"A:"</span>);&#125;</code></pre><h3 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h3><p><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a>在C++中地位非常高，被称为C++的准标准库，其中的ublas模块包含矩阵类，用法如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/numeric/ublas/matrix.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;boost/numeric/ublas/io.hpp&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">namespace</span> ublas = boost::numeric::ublas;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-function">ublas::matrix&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)</span></span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; A.size1(); ++i)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; A.size2(); ++j)            A(i, j) = <span class="hljs-number">3</span>*i + j;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; A &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++控制台设置滚动输出</title>
    <link href="/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/"/>
    <url>/2020/05/19/C-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AE%BE%E7%BD%AE%E6%BB%9A%E5%8A%A8%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写C++控制台程序时，我们可能会给程序添加进度条，也就是要程序在同一行反复输出，可以用特殊字符实现。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="在Windows下"><a href="#在Windows下" class="headerlink" title="在Windows下"></a>在Windows下</h3><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r"</span>);    fflush(<span class="hljs-built_in">stdout</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre><h3 id="在Linux下"><a href="#在Linux下" class="headerlink" title="在Linux下"></a>在Linux下</h3><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\033[k"</span>);    fflush(<span class="hljs-built_in">stdout</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这里写一个函数<code>setScrollOutput()</code>来实现这一过程：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScrollOutput</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN32</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\r\033[k"</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// _WIN32</span></span>fflush(<span class="hljs-built_in">stdout</span>);&#125;</code></pre><p>使用过程如下：</p><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-number">10</span>; ++i)&#123;    sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// do something</span>    setScrollOutput();    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"i = %d"</span>, i);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VMD原子选区语法</title>
    <link href="/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/05/19/VMD%E5%8E%9F%E5%AD%90%E9%80%89%E5%8C%BA%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h2><p>VMD（<a href="http://www.ks.uiuc.edu/Research/vmd/" target="_blank" rel="noopener">http://www.ks.uiuc.edu/Research/vmd/</a>）是极其强大、灵活的化学体系可视化程序，笔者之前也写过不少相关文章，见<a href="http://sobereva.com/category/VMD/" target="_blank" rel="noopener">http://sobereva.com/category/VMD/</a>。VMD的选择语句(selection)用来选择满足特定要求的体系中的原子，其用法极度简单灵活，对于VMD的使用至关重要。</p><p>选择语句在VMD里用的地方非常多，无处不在。比如如果想在图形窗口只显示指定的区域，那么可以在Graphics - Representation里在selected atoms的地方写上选择语句。如果想把指定的区域保存成新文件，那么可以在File - Save coordinates里在Selected atoms写上选择语句。很多自带的插件也需要选择语句，比如VMD自带的径向分布函数计算插件，里面selection 1、selection 2就是让你输入选择语句的地方。在VMD里还可以用atomselect命令创建对象，显然也要输入选择语句。顺带一提，如今GROMACS里也可以用selections语句，和VMD很大程度一致，但不完全一致。</p><p>鉴于经常有人问选择语句怎么用，每次回复很麻烦，笔者遂专门写个小文说一下。这些内容在“北京科音分子动力学与GROMACS培训班里”（<a href="http://www.keinsci.com/workshop/KGMX_content.html" target="_blank" rel="noopener">http://www.keinsci.com/workshop/KGMX_content.html</a>）里大多也都讲过，之前的学员可以复习一下。本文内容对应VMD 1.9.3。下文从简单到复杂进行讲解。</p><h2 id="2-单关键词（Singleword）"><a href="#2-单关键词（Singleword）" class="headerlink" title="2 单关键词（Singleword）"></a><strong>2 单关键词（Singleword）</strong></h2><p>有一些关键词可以直接选择特定原子，以下举例一部分：</p><p> all：所有原子</p><p> none：不选择任何原子</p><p> noh：氢以外的原子（即重原子）</p><p> ion：离子</p><p> water：水</p><p> backbone：生物大分子骨架</p><p> sidechain：生物大分子侧链</p><p> protein：蛋白</p><p> nucleic：核酸</p><p> helix：螺旋</p><p> alpha_helix：alpha螺旋（是helix中的子集，较长一段螺旋才算）</p><p> sheet：折叠</p><p> turn：转角</p><p> coil：盘绕</p><p> alpha：蛋白质的alpha碳</p><p> acidic：PH=7时带负电氨基酸</p><p> basic：PH=7时带正电氨基酸</p><p> charged：acidic和basic的并集</p><p> neutral：电中性氨基酸</p><p> polar：极性残基</p><p> hydrophobic：疏水性残基</p><p> bonded：成键的原子</p><p> hetero：非蛋白质和核酸的部分</p><p> carbon、hydrogen、oxygen、nitrogen、sulfur：相应元素。对于其它元素没法这么输入元素名来选择</p><p>这些单关键词实际上可以在Representation界面里的Selections标签页里的Singlewords直接看到，可见可以用的单关键词远不止上述这些。有些单关键词其实是复合选择语句，比如你选中hetero，就会看到其定义其实是not (protein or nucleic)。</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>注意有些情况下，单关键词未必能如实选择相应的区域。比如你载入的结构里有水，如果输入文件里水的残基名很特殊，比如叫FFF，那么VMD就不会把这个残基识别成水分子，用water关键词的时候也没法选中这些水。</p><h2 id="3-一般关键词"><a href="#3-一般关键词" class="headerlink" title="3 一般关键词"></a><strong>3 一般关键词</strong></h2><p>用下面这些关键词可以通过属性选取原子，都是后面要接参数的</p><p> name：原子名。例：name OW选择原子名叫OW的原子</p><p> index：原子序号（从0开始！）。例：index 4</p><p> serial：原子序号（从1开始）</p><p> type：原子类型。例：type CA选择CA原则类型</p><p> element：元素名。例：element P选择磷原子</p><p> resname：残基名。例：resname ALA代表选择丙氨酸</p><p> residue：残基编号，从0开始。例resid 372代表选择372号残基</p><p> resid：残基编号，从1开始。若结构文件里有残基号则与之一致</p><p> chain：链名。例：chain B代表选择B链</p><p> fragment：片段编号。VMD对每个键连的片段自动设定一个编号。例：fragment 4代表选择片段4</p><p> numbonds：成键数目。例：numbonds=2或numbonds 2代表选形成了两个键的原子</p><p> structure：二级结构。例：structure H代表选择螺旋(helix)区域</p><p> x,y,z：X/Y/Z笛卡尔坐标</p><p> vx,vy,vz：X/Y/Z方向速度</p><p> beta：pdb文件中的beta值</p><p> occupancy：pdb文件中的原子占有率</p><p> mass：原子质量</p><p> charge：原子电荷</p><p> phi、psi：蛋白质骨架角度</p><p> radius：原子半径</p><p>…等等</p><p>每个属性后面能接什么值，在Selections标签页里都能看到，不确定的话看一眼便知：</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p>许多属性并非对于任何输入文件都能用。比如：</p><p>·使用charge属性，必须输入的文件里体现了原子电荷才行，比如可以用mol2或pqr，后者详见《使用Multiwfn+VMD以原子着色方式表现原子电荷、自旋布居、电荷转移、简缩福井函数》（<a href="http://sobereva.com/425" target="_blank" rel="noopener">http://sobereva.com/425</a>）。</p><p>·使用beta属性，通常需要用pdb文件作为输入，因为里面专门有一列记录B因子信息。</p><p>·用type的话必须载入拓扑文件才行。</p><p>·用vx、vy、vz的话，对于GROMACS用户，参看《使VMD读入Gromacs产生的trr轨迹中速度信息的方法》（<a href="http://sobereva.com/117" target="_blank" rel="noopener">http://sobereva.com/117</a>）。</p><p>·element信息是很多文件里没有的，比如GROMACS的.gro文件里就没体现</p><h2 id="4-选择语句中可利用的规则"><a href="#4-选择语句中可利用的规则" class="headerlink" title="4 选择语句中可利用的规则"></a><strong>4 选择语句中可利用的规则</strong></h2><p>在选择语句中有以下规则可以利用，通过组合、嵌套，使得选择语句无比强大</p><p>·可以写多个参数一次选择一批，彼此间用空格分隔</p><p>·可以用… to …选择特定范围</p><p>·可以用与、或、非这些逻辑关系：and、or、not</p><p>·可以用( )或{ }指定语句处理的优先顺序</p><p>·双引号内的字符会被视为整体，并且可以使用正则表达式</p><p>·用单引号扩住则里面的字符可以避免被转义</p><p>·可以用判断语句：&lt;, &lt;=, =, &gt;=, &gt;, !=</p><p>·可以用函数：sqr（平方）, sqrt（开根号）, abs（绝对值）, sin, cos, tan, atan, asin, acos, sinh, cosh, tanh, exp, log, log10</p><p>·支持运算符：+ - * /。可以用^或**来表示多少次方</p><p>·特殊选择方式：</p><p> within 5 of AAA：距离AAA 5埃以内的原子。选取时不考虑周期边界条件，用pbwithin则考虑</p><p> exwithin 5 of AAA ：同上，但不包含AAA自身</p><p> withinbonds 2 of AAA：距离AAA不超过两个键的原子</p><p> same p as AAA：与AAA选区的p属性相同的部分</p><p> ringsize 5 from AAA：处于AAA中五元环上的原子</p><p> maxringsize 6 from AAA：处于AAA中&lt;=六元环的原子</p><p>下面来看一些具体例子</p><p> index 5 to 200 210：序号在5~200内的原子以及210号原子</p><p> protein or nucleic：蛋白质与核酸的原子</p><p> resname ALA CYS ARG：丙氨酸、半胱氨酸、精氨酸原子</p><p> backbone not helix：除了螺旋区域以外的骨架原子</p><p> name CA CB 或 name “CA|CB” 或 name “C[AB]” 或 name “C(A|B)”：名为CA和CB的原子</p><p> name “C.”：名字为两个字符且第一个字符为C的原子</p><p> name “CE[1-3]”：名字为CE1、CE2、CE3的原子</p><p> name ‘O5<em>‘：叫O5</em>的原子。注意原子名带星号的在选取时要用单引号括住以免转义</p><p> resname ‘CA2+’：残基名是CA2+的原子（二价钙离子）。名字带正负号的也要用单引号括住以免转义</p><p> mass &gt; 5：质量大于5的原子</p><p> abs(charge)&gt;1：电荷大小超过1的原子</p><p> x&lt;6 and x&gt;3：选择x在3~6埃区域内的一层原子</p><p> x&gt;1 and x&lt;8 and y&gt;24 and y&lt;35 and z&gt;1 and z&lt;5：一个矩形区域内的原子</p><p> sqr(x-5)+sqr(y+4)+sqr(z) &lt; sqr(5) ：以(5,-4,0)点为中心半径5埃以内的原子</p><p> ((x-33)^2+(y-14.5)^2)&lt;12^2 and z&lt;40 and z&gt;10：选择以x=33、y=14.5埃为中心，半径为12埃，z范围在10~40埃的柱形区域</p><p> x+y+z&lt;80：斜切面内侧的原子（回忆平面方程）</p><p> not {oxygen and numbonds=0}：扣除孤立的氧原子（可以用于去除X光衍射pdb文件里的结晶水）</p><p> within 6 of protein：距离蛋白质6埃以内的原子</p><p> not within 5 of resname ADP：距离名为ADP的分子5埃以外的原子</p><p> water within 5 of residue 8 to 44：距离8~44号残基5埃以内的水</p><p> withinbonds 2 of index 31：距离编号为31原子的两个键及以内的原子</p><p> maxringsize 6 from protein：蛋白当中所有六元及六元以下环上的原子</p><p> same resname as resid 33：所有与33号残基相同名称的残基</p><p> same residue as {protein within 5 of nucleic}：与核酸的原子相距5埃以内的蛋白的原子，并且把被截断的残基保留完整</p><p> x &gt; 15 and not same fragment as {exwithin 8 of protein}：蛋白质以及蛋白质8埃范围以外的原子，保留完整片段，同时x坐标得大于15埃</p><p>以上例子中，涉及到坐标、速度变量的，属于动态选区，即随着帧号变化被选择的原子会可能发生变化。观看这些选区的时候，注意在Representation界面的Trajectory标签页里要把Update Selection Every Frame选上，否则选中的原子是对刚选中时那一帧而言的，不会随着轨迹播放被动态更新。在一些VMD的插件中，比如计算rdf的Radial Pair Distribution Function g(r)插件里，当Selection文本框里用了动态选区时，应当把Update Selections复选框选上，否则也由于不会被动态更新而和期望的不符。</p><blockquote><p>转自 <a href="http://bbs.keinsci.com/thread-14267-1-1.html" target="_blank" rel="noopener">http://bbs.keinsci.com/thread-14267-1-1.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VMD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具网站汇总</title>
    <link href="/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/"/>
    <url>/2020/05/19/%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ul><li><a href="http://tinyambition.com/h2m/" target="_blank" rel="noopener">HTML转Markdown</a></li><li><a href="https://pandao.github.io/editor.md/" target="_blank" rel="noopener">在线Markdown编辑器</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab绘制图组</title>
    <link href="/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/"/>
    <url>/2020/05/19/Matlab%E7%BB%98%E5%88%B6%E5%9B%BE%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在用Matlab的<code>subplot</code>函数绘制图组时可能会发现子图之间的间距不太好看，可以通过<code>set(&#39;Position&#39;, [l, b, w, h])</code>函数来分别调整，比较麻烦，这里我写了一个函数<code>subplot_adjust</code>来简化这一过程。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>function <code>subplots_adjust(row, col, varargin)</code></p><p>Tune the subplot layout.</p><p>The parameter meanings (and suggested defaults) are</p><pre><code>left = 0.12    # the left side of the subplots of the figurebottom = 0.138 # the bottom of the subplots of the figurewidth = 0.8    # the width of the subplots of the figurehight = 0.78   # the hight of the subplots of the figurewspace = 0.12  # the amount of width reserved for space between subplots,               # expressed as a fraction of the average axis widthhspace = 0.1   # the amount of height reserved for space between subplots,               # expressed as a fraction of the average axis heightsupPosition = [0.075, 0.08, 0.9, 0.85]                # [left, bottom, width, hight]               # super axes position, which controls position of               # supxlabel, supylabel and suptitle.</code></pre><p>在用<code>subplot</code>画完图组后，直接在最后面加上<code>subplot_adjust</code>即可，例如：</p><pre><code class="hljs matlab">x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);y1 = <span class="hljs-built_in">sin</span>(x);y2 = <span class="hljs-built_in">cos</span>(x);<span class="hljs-built_in">figure</span>(<span class="hljs-string">'Position'</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">50</span>, <span class="hljs-number">400</span>, <span class="hljs-number">550</span>]);subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<span class="hljs-built_in">plot</span>(x, y1)subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<span class="hljs-built_in">plot</span>(x, y2)ax = subplots_adjust(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'hspace'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'left'</span>, <span class="hljs-number">0.2</span>, ...                    <span class="hljs-string">'width'</span>, <span class="hljs-number">0.75</span>, <span class="hljs-string">'supPosition'</span>, [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.85</span>]);xlabel(ax, <span class="hljs-string">'xlabel'</span>)ylabel(ax, <span class="hljs-string">'ylabel'</span>)title(ax, <span class="hljs-string">'Title'</span>)</code></pre><p>绘制2行1列图组，设置两子图之间纵向间距为0，结果如下：</p><div align=center><img src="subplot_adjust.png" srcset="/img/loading.gif" width="50%" height="50%"></div><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="/download/subplot_adjust.m" download>Download File</a></p><p><a href="/download/subplot_adjust.m">点击下载subplot_adjust.m</a></p><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ax</span> = <span class="hljs-title">subplots_adjust</span><span class="hljs-params">(row, col, varargin)</span></span><span class="hljs-comment">%% function subplots_adjust(row, col, varargin)</span><span class="hljs-comment">% Tune the subplot layout.</span><span class="hljs-comment">% </span><span class="hljs-comment">% The parameter meanings (and suggested defaults) are::</span><span class="hljs-comment">% </span><span class="hljs-comment">%   left = 0.12    # the left side of the subplots of the figure</span><span class="hljs-comment">%   bottom = 0.138 # the bottom of the subplots of the figure</span><span class="hljs-comment">%   width = 0.8    # the width of the subplots of the figure</span><span class="hljs-comment">%   hight = 0.78   # the hight of the subplots of the figure</span><span class="hljs-comment">%   wspace = 0.12  # the amount of width reserved for space between subplots,</span><span class="hljs-comment">%                  # expressed as a fraction of the average axis width</span><span class="hljs-comment">%   hspace = 0.1   # the amount of height reserved for space between subplots,</span><span class="hljs-comment">%                  # expressed as a fraction of the average axis height</span><span class="hljs-comment">%   supPosition = [0.075, 0.08, 0.9, 0.85] </span><span class="hljs-comment">%                  # [left, bottom, width, hight]</span><span class="hljs-comment">%                  # super axes position, which controls position of</span><span class="hljs-comment">%                  # supxlabel, supylabel and suptitle.</span><span class="hljs-comment">%</span><span class="hljs-comment">% Example:</span><span class="hljs-comment">% x = linspace(0, 10);</span><span class="hljs-comment">% y1 = sin(x);</span><span class="hljs-comment">% y2 = cos(x);</span><span class="hljs-comment">% figure('Position', [10, 50, 400, 550]);</span><span class="hljs-comment">% subplot(2, 1, 1)</span><span class="hljs-comment">% plot(x, y1)</span><span class="hljs-comment">% subplot(2, 1, 2)</span><span class="hljs-comment">% plot(x, y2)</span><span class="hljs-comment">% ax = subplots_adjust(2, 1, 'hspace', 0, 'left', 0.2, ...</span><span class="hljs-comment">%                      'width', 0.75, 'supPosition', [0.1, 0.08, 0.95, 0.85]);</span><span class="hljs-comment">% xlabel(ax, 'xlabel')</span><span class="hljs-comment">% ylabel(ax, 'ylabel')</span><span class="hljs-comment">% title(ax, 'Title')</span>p = inputParser;addRequired(p, <span class="hljs-string">'row'</span>);addRequired(p, <span class="hljs-string">'col'</span>);addParameter(p, <span class="hljs-string">'wspace'</span>, <span class="hljs-number">0.12</span>);addParameter(p, <span class="hljs-string">'hspace'</span>, <span class="hljs-number">0.1</span>);addParameter(p, <span class="hljs-string">'left'</span>, <span class="hljs-number">0.12</span>);addParameter(p, <span class="hljs-string">'bottom'</span>, <span class="hljs-number">0.138</span>);addParameter(p, <span class="hljs-string">'width'</span>, <span class="hljs-number">0.8</span>);addParameter(p, <span class="hljs-string">'hight'</span>, <span class="hljs-number">0.78</span>);addParameter(p, <span class="hljs-string">'supPosition'</span>, [<span class="hljs-number">0.075</span>, <span class="hljs-number">0.08</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.85</span>]);parse(p, row, col, varargin&#123;:&#125;);left   = p.Results.left;bottom = p.Results.bottom;width  = p.Results.width;hight  = p.Results.hight;space = [p.Results.wspace, p.Results.hspace];eachx = (width-(col<span class="hljs-number">-1</span>)*space(<span class="hljs-number">1</span>)) / col;eachy = (hight-(row<span class="hljs-number">-1</span>)*space(<span class="hljs-number">2</span>)) / row;<span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:row    <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:col        h = subplot(row, col, (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*col+<span class="hljs-built_in">j</span>);        set(h, <span class="hljs-string">'position'</span>, [left+(<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)*(eachx+space(<span class="hljs-number">1</span>)), bottom+(row-<span class="hljs-built_in">i</span>)*(eachy+space(<span class="hljs-number">2</span>)), eachx, eachy]);        <span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span> ~= <span class="hljs-number">1</span> &amp;&amp; space(<span class="hljs-number">1</span>) == <span class="hljs-number">0</span>            set(h, <span class="hljs-string">'YTickLabel'</span>, &#123;&#125;);        <span class="hljs-keyword">end</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">i</span> ~= row &amp;&amp; space(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>            set(h, <span class="hljs-string">'XTickLabel'</span>, &#123;&#125;);        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>ax = axes(<span class="hljs-string">'Units'</span>, <span class="hljs-string">'Normal'</span>, <span class="hljs-string">'Position'</span>, p.Results.supPosition, <span class="hljs-string">'Visible'</span>, <span class="hljs-string">'off'</span>);ax.XTickLabel = &#123;&#125;;ax.YTickLabel = &#123;&#125;;ax.XLabel.Visible = <span class="hljs-string">'on'</span>;ax.YLabel.Visible = <span class="hljs-string">'on'</span>;ax.Title.Visible = <span class="hljs-string">'on'</span>;<span class="hljs-keyword">end</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python线程池的创建和使用</title>
    <link href="/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/05/19/Python%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="✨-前言"><a href="#✨-前言" class="headerlink" title="✨ 前言"></a>✨ 前言</h3><p>从Python3.2开始，标准库为我们提供了 concurrent.futures 模块，它提供了 ThreadPoolExecutor (线程池)和ProcessPoolExecutor (进程池)两个类。</p><p>相比 threading 等模块，该模块通过 submit 返回的是一个 future 对象，它是一个未来可期的对象，通过它可以获悉线程的状态主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值：</p><ol><li>主线程可以获取某一个线程（或者任务的）的状态，以及返回值。</li><li>当一个线程完成的时候，主线程能够立即知道。</li><li>让多线程和多进程的编码接口一致。</li></ol><h3 id="✨-线程池的基本使用"><a href="#✨-线程池的基本使用" class="headerlink" title="✨ 线程池的基本使用"></a>✨ 线程池的基本使用</h3><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:  <span class="hljs-comment"># 创建一个最大容纳数量为5的线程池</span>    task1 = t.submit(spider, <span class="hljs-number">1</span>)    task2 = t.submit(spider, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 通过submit提交执行的函数到线程池中</span>    task3 = t.submit(spider, <span class="hljs-number">3</span>)    print(<span class="hljs-string">f"task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>"</span>)  <span class="hljs-comment"># 通过done来判断线程是否完成</span>    print(<span class="hljs-string">f"task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>"</span>)    time.sleep(<span class="hljs-number">2.5</span>)    print(<span class="hljs-string">f"task1: <span class="hljs-subst">&#123;task1.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task2: <span class="hljs-subst">&#123;task2.done()&#125;</span>"</span>)    print(<span class="hljs-string">f"task3: <span class="hljs-subst">&#123;task3.done()&#125;</span>"</span>)    print(task1.result())  <span class="hljs-comment"># 通过result来获取返回值</span></code></pre><h5 id="执行结果如下"><a href="#执行结果如下" class="headerlink" title="执行结果如下:"></a>执行结果如下:</h5><pre><code class="hljs plain">task1: Falsetask2: Falsetask3: Falsecrawl task1 finishedcrawl task2 finishedtask1: Truetask2: Truetask3: False1crawl task3 finished</code></pre><ol><li><p>使用 with 语句 ，通过 ThreadPoolExecutor 构造实例，同时传入 max_workers 参数来设置线程池中最多能同时运行的线程数目。</p></li><li><p>使用 submit 函数来提交线程需要执行的任务到线程池中，并返回该任务的句柄（类似于文件、画图），注意 submit() 不是阻塞的，而是立即返回。</p></li><li><p>通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。</p></li><li><p>使用 result() 方法可以获取任务的返回值。</p></li></ol><h3 id="✨-主要方法："><a href="#✨-主要方法：" class="headerlink" title="✨ 主要方法："></a>✨ 主要方法：</h3><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><pre><code class="hljs plain">wait(fs, timeout&#x3D;None, return_when&#x3D;ALL_COMPLETED)</code></pre><p>wait 接受三个参数： fs: 表示需要执行的序列 timeout: 等待的最大时间，如果超过这个时间即使线程未执行完成也将返回 return_when：表示wait返回结果的条件，默认为 ALL_COMPLETED 全部执行完成再返回</p><p>还是用上面那个例子来熟悉用法 示例：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED, ALL_COMPLETED<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:     all_task = [t.submit(spider, page) <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)]    wait(all_task, return_when=FIRST_COMPLETED)    print(<span class="hljs-string">'finished'</span>)    print(wait(all_task, timeout=<span class="hljs-number">2.5</span>))<span class="hljs-comment"># 运行结果</span>crawl task1 finishedfinishedcrawl task2 finishedcrawl task3 finishedDoneAndNotDoneFutures(done=&#123;, , &#125;, not_done=&#123;&#125;)crawl task4 finished</code></pre><ol><li>代码中返回的条件是：当完成第一个任务的时候，就停止等待，继续主线程任务</li><li>由于设置了延时， 可以看到最后只有 task4 还在运行中</li></ol><h4 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h4><p>上面虽然提供了判断任务是否结束的方法，但是不能在主线程中一直判断啊。最好的方法是当某个任务结束了，就给主线程返回结果，而不是一直判断每个任务是否结束。</p><p>ThreadPoolExecutorThreadPoolExecutor 中 的 as_completed() 就是这样一个方法，当子线程中的任务执行完后，直接用 result() 获取返回结果</p><p>用法如下：</p><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    print(<span class="hljs-string">f"crawl task<span class="hljs-subst">&#123;page&#125;</span> finished"</span>)    <span class="hljs-keyword">return</span> page<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> t:        obj_list = []        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):            obj = t.submit(spider, page)            obj_list.append(obj)        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):            data = future.result()            print(<span class="hljs-string">f"main: <span class="hljs-subst">&#123;data&#125;</span>"</span>)<span class="hljs-comment"># 执行结果</span>crawl task1 finishedmain: <span class="hljs-number">1</span>crawl task2 finishedmain: <span class="hljs-number">2</span>crawl task3 finishedmain: <span class="hljs-number">3</span>crawl task4 finishedmain: <span class="hljs-number">4</span></code></pre><p>as_completed() 方法是一个生成器，在没有任务完成的时候，会一直阻塞，除非设置了 timeout。</p><p>当有某个任务完成的时候，会 yield 这个任务，就能执行 for 循环下面的语句，然后继续阻塞住，循环到所有的任务结束。同时，先完成的任务会先返回给主线程。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><pre><code class="hljs plain">map(fn, *iterables, timeout&#x3D;None)</code></pre><p>fn： 第一个参数 fn 是需要线程执行的函数； iterables：第二个参数接受一个可迭代对象； timeout： 第三个参数 timeout 跟 wait() 的 timeout 一样，但由于 map 是返回线程执行的结果，如果 timeout小于线程执行时间会抛异常 TimeoutError。</p><p>用法如下:</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    time.sleep(page)    <span class="hljs-keyword">return</span> pagestart = time.time()executor = ThreadPoolExecutor(max_workers=<span class="hljs-number">4</span>)i = <span class="hljs-number">1</span><span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> executor.map(spider, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]):    print(<span class="hljs-string">"task&#123;&#125;:&#123;&#125;"</span>.format(i, result))    i += <span class="hljs-number">1</span><span class="hljs-comment">#  运行结果</span>task1:<span class="hljs-number">2</span>task2:<span class="hljs-number">3</span>task3:<span class="hljs-number">1</span>task4:<span class="hljs-number">4</span></code></pre><p>使用 map 方法，无需提前使用 submit 方法，map 方法与 python 高阶函数 map 的含义相同，都是将序列中的每个元素都执行同一个函数。</p><p>上面的代码对列表中的每个元素都执行 spider() 函数，并分配各线程池。</p><p>可以看到执行结果与上面的 as_completed() 方法的结果不同，输出顺序和列表的顺序相同，就算 1s 的任务先执行完成，也会先打印前面提交的任务返回的结果。</p><h3 id="✨-实战"><a href="#✨-实战" class="headerlink" title="✨ 实战"></a>✨ 实战</h3><p>以某网站为例，演示线程池和单线程两种方式爬取的差异</p><pre><code class="hljs python"><span class="hljs-comment"># coding: utf-8</span><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, as_completed<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> json<span class="hljs-keyword">from</span> requests <span class="hljs-keyword">import</span> adapters<span class="hljs-keyword">from</span> proxy <span class="hljs-keyword">import</span> get_proxiesheaders = &#123;    <span class="hljs-string">"Host"</span>: <span class="hljs-string">"splcgk.court.gov.cn"</span>,    <span class="hljs-string">"Origin"</span>: <span class="hljs-string">"https://splcgk.court.gov.cn"</span>,    <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"</span>,    <span class="hljs-string">"Referer"</span>: <span class="hljs-string">"https://splcgk.court.gov.cn/gzfwww/ktgg"</span>,&#125;url = <span class="hljs-string">"https://splcgk.court.gov.cn/gzfwww/ktgglist?pageNo=1"</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">spider</span><span class="hljs-params">(page)</span>:</span>    data = &#123;        <span class="hljs-string">"bt"</span>: <span class="hljs-string">""</span>,        <span class="hljs-string">"fydw"</span>: <span class="hljs-string">""</span>,        <span class="hljs-string">"pageNum"</span>: page,    &#125;    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        <span class="hljs-keyword">try</span>:            response = requests.post(url, headers=headers, data=data, proxies=get_proxies())            json_data = response.json()        <span class="hljs-keyword">except</span> (json.JSONDecodeError, adapters.SSLError):            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> &#123;&#125;    <span class="hljs-keyword">return</span> json_data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">8</span>) <span class="hljs-keyword">as</span> t:        obj_list = []        begin = time.time()        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):            obj = t.submit(spider, page)            obj_list.append(obj)        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> as_completed(obj_list):            data = future.result()            print(data)            print(<span class="hljs-string">'*'</span> * <span class="hljs-number">50</span>)        times = time.time() - begin        print(times)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    main()</code></pre><p>运行结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/6/16b2cf5c38d862ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="多线程"></p><p><strong>可以看到，14 页只花了 2 秒钟就爬完了</strong></p><p>下面我们可以使用单线程来爬取，代码基本和上面的一样，加个单线程函数 代码如下:</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">single</span><span class="hljs-params">()</span>:</span>    begin = time.time()    <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>):        data = spider(page)        print(data)        print(<span class="hljs-string">'*'</span> * <span class="hljs-number">50</span>)    times = time.time() - begin    print(times)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:    single()</code></pre><p>运行结果：</p><p><img src="data:image/svg+xml;utf8," srcset="/img/loading.gif" alt="单线程"></p><p><strong>可以看到，总共花了 19 秒。真是肉眼可见的差距啊！如果数据量大的话，运行时间差距会更大！</strong></p><blockquote><p>转自：<a href="https://juejin.im/post/5cf913cfe51d45105d63a4d0" target="_blank" rel="noopener">https://juejin.im/post/5cf913cfe51d45105d63a4d0</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Program</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
